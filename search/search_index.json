{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Source code: https://github.com/volfpeter/fasted</p> <p>Documentation and examples: https://volfpeter.github.io/fasted</p>"},{"location":"#fasted","title":"FastED","text":"<p>FastAPI dependencies and utilities.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed with:</p> <pre><code>$ pip install fasted\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#selfdependent","title":"<code>selfdependent</code>","text":"<p>Decorator that let's you use your business objects' instance methods as FastAPI dependencies without writing any additional code.</p> <p>Supports:</p> <ul> <li>Sync and async instance methods.</li> <li>Sync and async generator methods.</li> <li>Inheritence and <code>super()</code> calls is decorated methods.</li> <li>An optional factory (FastAPI dependency) for creating the <code>self</code> instance. If not set, the class' <code>__init__()</code> method will serve as the dependency for creating the <code>self</code> instance.</li> <li>Decorated instance methods will behave as expected if called directly.</li> </ul> <p>Example use:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\nfrom fasted import selfdependent\n\n\ndef double() -&gt; \"Multiplier\":\n    # Dependency that returns a Multiplier with base = 2.\n    return Multiplier(2)\n\n\nclass Multiplier:\n    def __init__(self, base: float) -&gt; None:\n        self.base = base\n\n    @selfdependent()\n    def multiply(self, mul: float) -&gt; float:\n        # `__init__()` will be used as the dependency to create `self`, so the route\n        # where this method is used will have a `base` and a `mul` query parameter.\n        return self.base * mul\n\n    @selfdependent(factory=double)\n    async def double(self, mul: float) -&gt; float:\n        # `double()` will be used as the dependency to create `self`, so the route\n        # where this method is used will only have a `mul` query parameter.\n        return self.base * mul\n\n\napp = FastAPI()\n\n\n@app.get(\"/multiply\")\ndef multiply_route(value: Annotated[float, Depends(Multiplier.multiply)]) -&gt; float:\n    # FastAPI will create the `Multiplier` instance based on `Multiplier.__init__()` and\n    # automatically feed this `instance` as `self` to `Multiplier.multiply()` to calculate\n    # the value of the dependency.\n    return value\n\n\n@app.get(\"/double\")\ndef double_route(value: Annotated[float, Depends(Multiplier.double)]) -&gt; float:\n    # FastAPI will create the `Multiplier` instance using the `double()` factory (dependency)\n    # and automatically feed this instance as `self` to `Multiplier.multiply()` to\n    # calculate the value of the dependency.\n    return value\n</code></pre>"},{"location":"#dependency","title":"<code>Dependency</code>","text":"<p>Generic type for FastAPI dependencies.</p> <p>Example use:</p> <pre><code>from typing import Annotated, Generator\n\nfrom fastapi import FastAPI, APIRouter\nfrom fasted import Dependency\n# from x import Session\n\n\ndef make_api(make_session: Dependency[Session]) -&gt; APIRouter:\n    DependsSession = Annotated[Session, Depends(make_session)]\n\n    api = APIRouter()\n\n    @api.get(\"/\")\n    def get(session: DependsSession) -&gt; int:\n        return 4\n\n    return api\n\n\ndef make_db_session() -&gt; Generator[Session, None, None]:\n    with Session(database) as session:\n        yield session\n\n\napp = FastAPI()\napp.include_router(make_api(make_db_session), prefix=\"/random-number\")\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Being a FastAPI utility library, the only dependency is (and will remain) <code>fastapi</code>.</p>"},{"location":"#development","title":"Development","text":"<p>Use <code>ruff</code> for linting and formatting, <code>mypy</code> for static code analysis, and <code>pytest</code> for testing.</p> <p>The documentation is built with <code>mkdocs-material</code> and <code>mkdocstrings</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions are welcome.</p>"},{"location":"#license-mit","title":"License - MIT","text":"<p>The package is open-sourced under the conditions of the MIT license.</p>"},{"location":"api-selfdependent/","title":"<code>selfdependent()</code>","text":"<p>Decorator that converts an instance method into a FastAPI dependency using a <code>SelfDependent</code> descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>Dependency[TOwner] | None</code> <p>An optional factory (and FastAPI dependency) that can be wrapped in <code>Depends()</code> and that produces the <code>self</code> argument for the wrapped method.</p> <code>None</code> Source code in <code>fasted/selfdependent.py</code> <pre><code>def selfdependent(\n    *,\n    factory: Dependency[TOwner] | None = None,\n) -&gt; Callable[[BoundMethod[TOwner, TParams, TResult]], BoundMethod[TOwner, TParams, TResult]]:\n    \"\"\"\n    Decorator that converts an instance method into a FastAPI dependency using a `SelfDependent` descriptor.\n\n    Arguments:\n        factory: An optional factory (and FastAPI dependency) that can be wrapped in `Depends()`\n            and that produces the `self` argument for the wrapped method.\n    \"\"\"\n\n    def decorator(\n        func: Callable[Concatenate[TOwner, TParams], TResult],\n    ) -&gt; SelfDependent[TOwner, TParams, TResult]:\n        return SelfDependent[TOwner, TParams, TResult](wrapped=func, factory=factory)\n\n    # This type ignore is necessary for mypy in case the decorated method is overridden in a subclass.\n    return decorator  # type: ignore\n</code></pre>"},{"location":"api-selfdependent/#selfdependent_1","title":"<code>SelfDependent</code>","text":"<p>             Bases: <code>Generic[TOwner, TParams, TResult]</code></p> <p>Descriptor whose value is a method (FastAPI dependency) with an annotated <code>self</code> argument that can be processed and used by FastAPI as a dependency.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>class SelfDependent(Generic[TOwner, TParams, TResult]):\n    \"\"\"\n    Descriptor whose value is a method (FastAPI dependency) with an annotated\n    `self` argument that can be processed and used by FastAPI as a dependency.\n    \"\"\"\n\n    __slots__ = (\"_wrapped\", \"_factory\", \"_memo\")\n\n    def __init__(\n        self,\n        wrapped: Callable[Concatenate[TOwner, TParams], TResult],\n        *,\n        factory: Dependency[TOwner] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            wrapped: The wrapped function.\n            factory: An optional factory for creating `self` instances.\n        \"\"\"\n        self._wrapped = wrapped\n        self._factory = factory\n        self._memo = IdMemo[Callable[TParams, TResult]]()\n\n    def __get__(self, owner: TOwner | None, obj_type: type[TOwner]) -&gt; Callable[TParams, TResult]:\n        memo = self._memo\n        hcurrent = memo.hash(owner, obj_type)\n        if hcurrent in memo:\n            return self._memo.value\n\n        result: Callable[TParams, TResult]\n        wrapped = self._wrapped\n        if inspect.isgeneratorfunction(wrapped):\n            result = SelfWrapper.sync_generator(wrapped, owner)  # type: ignore[assignment]\n        elif inspect.isasyncgenfunction(wrapped):\n            result = SelfWrapper.async_generator(wrapped, owner)  # type: ignore[assignment]\n        elif asyncio.iscoroutinefunction(wrapped):\n            result = SelfWrapper.async_method(wrapped, owner)  # type: ignore[assignment]\n        else:\n            result = SelfWrapper.sync_method(wrapped, owner)\n\n        replace_self_signature(\n            result,\n            inspect.Parameter(\n                \"self\",\n                inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                annotation=Annotated[obj_type, Depends(self._factory or obj_type)],\n            ),\n        )\n\n        return self._memo.store(hcurrent, result)\n</code></pre>"},{"location":"api-selfdependent/#fasted.selfdependent.SelfDependent.__init__","title":"<code>__init__(wrapped, *, factory=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped</code> <code>Callable[Concatenate[TOwner, TParams], TResult]</code> <p>The wrapped function.</p> required <code>factory</code> <code>Dependency[TOwner] | None</code> <p>An optional factory for creating <code>self</code> instances.</p> <code>None</code> Source code in <code>fasted/selfdependent.py</code> <pre><code>def __init__(\n    self,\n    wrapped: Callable[Concatenate[TOwner, TParams], TResult],\n    *,\n    factory: Dependency[TOwner] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        wrapped: The wrapped function.\n        factory: An optional factory for creating `self` instances.\n    \"\"\"\n    self._wrapped = wrapped\n    self._factory = factory\n    self._memo = IdMemo[Callable[TParams, TResult]]()\n</code></pre>"},{"location":"api-selfdependent/#selfwrapper","title":"<code>SelfWrapper</code>","text":"<p><code>SelfDependent</code> function wrappers that populate the <code>self</code> argument of the wrapped function from the keyword arguments (if one was provided), or use the owner instance if one wasn't provided. Thus the wrapped \"static\" methods can behave as if they were instance methods.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>class SelfWrapper:\n    \"\"\"\n    `SelfDependent` function wrappers that populate the `self` argument of the wrapped function\n    from the keyword arguments (if one was provided), or use the owner instance if one wasn't\n    provided. Thus the wrapped \"static\" methods can behave as if they were instance methods.\n    \"\"\"\n\n    @classmethod\n    def sync_method(\n        cls,\n        func: Callable[Concatenate[TOwner, TParams], TResult],\n        owner: TOwner | None,\n    ) -&gt; Callable[TParams, TResult]:\n        \"\"\"\n        Wrapper for synchronous methods.\n\n        Arguments:\n            func: The function to wrap.\n            owner: An optional owner object.\n\n        Returns:\n            The wrapper.\n        \"\"\"\n\n        @wraps(func)\n        def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; TResult:\n            func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n            if func_self is None:\n                raise RuntimeError(\"Missing self argument.\")\n\n            return func(func_self, *args, **kwargs)\n\n        return do\n\n    @classmethod\n    def sync_generator(\n        cls,\n        func: Callable[Concatenate[TOwner, TParams], Generator[TResult, Any, Any]],\n        owner: TOwner | None,\n    ) -&gt; Callable[TParams, Generator[TResult, None, None]]:\n        \"\"\"\n        Wrapper for synchronous generator methods.\n\n        Arguments:\n            func: The function to wrap.\n            owner: An optional owner object.\n\n        Returns:\n            The wrapper.\n        \"\"\"\n\n        @wraps(func)\n        def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; Generator[TResult, None, None]:\n            func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n            if func_self is None:\n                raise RuntimeError(\"Missing self argument.\")\n\n            yield from func(func_self, *args, **kwargs)\n\n        return do\n\n    @classmethod\n    def async_method(\n        cls,\n        func: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, TResult]],\n        owner: TOwner | None,\n    ) -&gt; Callable[TParams, Coroutine[None, None, TResult]]:\n        \"\"\"\n        Wrapper for asynchronous methods.\n\n        Arguments:\n            func: The function to wrap.\n            owner: An optional owner object.\n\n        Returns:\n            The wrapper.\n        \"\"\"\n\n        @wraps(func)\n        async def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; TResult:\n            func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n            if func_self is None:\n                raise RuntimeError(\"Missing self argument.\")\n\n            return await func(func_self, *args, **kwargs)\n\n        return do\n\n    @classmethod\n    def async_generator(\n        cls,\n        func: Callable[\n            Concatenate[TOwner, TParams],\n            AsyncGenerator[TResult, None],\n        ],\n        owner: TOwner | None,\n    ) -&gt; Callable[TParams, AsyncGenerator[TResult, None]]:\n        \"\"\"\n        Wrapper for asynchronous generator methods.\n\n        Arguments:\n            func: The function to wrap.\n            owner: An optional owner object.\n\n        Returns:\n            The wrapper.\n        \"\"\"\n\n        @wraps(func)\n        async def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; AsyncGenerator[TResult, None]:\n            func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n            if func_self is None:\n                raise RuntimeError(\"Missing self argument.\")\n\n            async for res in func(func_self, *args, **kwargs):\n                yield res\n\n        return do\n</code></pre>"},{"location":"api-selfdependent/#fasted.selfdependent.SelfWrapper.async_generator","title":"<code>async_generator(func, owner)</code>  <code>classmethod</code>","text":"<p>Wrapper for asynchronous generator methods.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[TOwner, TParams], AsyncGenerator[TResult, None]]</code> <p>The function to wrap.</p> required <code>owner</code> <code>TOwner | None</code> <p>An optional owner object.</p> required <p>Returns:</p> Type Description <code>Callable[TParams, AsyncGenerator[TResult, None]]</code> <p>The wrapper.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>@classmethod\ndef async_generator(\n    cls,\n    func: Callable[\n        Concatenate[TOwner, TParams],\n        AsyncGenerator[TResult, None],\n    ],\n    owner: TOwner | None,\n) -&gt; Callable[TParams, AsyncGenerator[TResult, None]]:\n    \"\"\"\n    Wrapper for asynchronous generator methods.\n\n    Arguments:\n        func: The function to wrap.\n        owner: An optional owner object.\n\n    Returns:\n        The wrapper.\n    \"\"\"\n\n    @wraps(func)\n    async def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; AsyncGenerator[TResult, None]:\n        func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n        if func_self is None:\n            raise RuntimeError(\"Missing self argument.\")\n\n        async for res in func(func_self, *args, **kwargs):\n            yield res\n\n    return do\n</code></pre>"},{"location":"api-selfdependent/#fasted.selfdependent.SelfWrapper.async_method","title":"<code>async_method(func, owner)</code>  <code>classmethod</code>","text":"<p>Wrapper for asynchronous methods.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[TOwner, TParams], Coroutine[None, None, TResult]]</code> <p>The function to wrap.</p> required <code>owner</code> <code>TOwner | None</code> <p>An optional owner object.</p> required <p>Returns:</p> Type Description <code>Callable[TParams, Coroutine[None, None, TResult]]</code> <p>The wrapper.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>@classmethod\ndef async_method(\n    cls,\n    func: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, TResult]],\n    owner: TOwner | None,\n) -&gt; Callable[TParams, Coroutine[None, None, TResult]]:\n    \"\"\"\n    Wrapper for asynchronous methods.\n\n    Arguments:\n        func: The function to wrap.\n        owner: An optional owner object.\n\n    Returns:\n        The wrapper.\n    \"\"\"\n\n    @wraps(func)\n    async def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; TResult:\n        func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n        if func_self is None:\n            raise RuntimeError(\"Missing self argument.\")\n\n        return await func(func_self, *args, **kwargs)\n\n    return do\n</code></pre>"},{"location":"api-selfdependent/#fasted.selfdependent.SelfWrapper.sync_generator","title":"<code>sync_generator(func, owner)</code>  <code>classmethod</code>","text":"<p>Wrapper for synchronous generator methods.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[TOwner, TParams], Generator[TResult, Any, Any]]</code> <p>The function to wrap.</p> required <code>owner</code> <code>TOwner | None</code> <p>An optional owner object.</p> required <p>Returns:</p> Type Description <code>Callable[TParams, Generator[TResult, None, None]]</code> <p>The wrapper.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>@classmethod\ndef sync_generator(\n    cls,\n    func: Callable[Concatenate[TOwner, TParams], Generator[TResult, Any, Any]],\n    owner: TOwner | None,\n) -&gt; Callable[TParams, Generator[TResult, None, None]]:\n    \"\"\"\n    Wrapper for synchronous generator methods.\n\n    Arguments:\n        func: The function to wrap.\n        owner: An optional owner object.\n\n    Returns:\n        The wrapper.\n    \"\"\"\n\n    @wraps(func)\n    def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; Generator[TResult, None, None]:\n        func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n        if func_self is None:\n            raise RuntimeError(\"Missing self argument.\")\n\n        yield from func(func_self, *args, **kwargs)\n\n    return do\n</code></pre>"},{"location":"api-selfdependent/#fasted.selfdependent.SelfWrapper.sync_method","title":"<code>sync_method(func, owner)</code>  <code>classmethod</code>","text":"<p>Wrapper for synchronous methods.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[TOwner, TParams], TResult]</code> <p>The function to wrap.</p> required <code>owner</code> <code>TOwner | None</code> <p>An optional owner object.</p> required <p>Returns:</p> Type Description <code>Callable[TParams, TResult]</code> <p>The wrapper.</p> Source code in <code>fasted/selfdependent.py</code> <pre><code>@classmethod\ndef sync_method(\n    cls,\n    func: Callable[Concatenate[TOwner, TParams], TResult],\n    owner: TOwner | None,\n) -&gt; Callable[TParams, TResult]:\n    \"\"\"\n    Wrapper for synchronous methods.\n\n    Arguments:\n        func: The function to wrap.\n        owner: An optional owner object.\n\n    Returns:\n        The wrapper.\n    \"\"\"\n\n    @wraps(func)\n    def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; TResult:\n        func_self: TOwner = kwargs.pop(\"self\") if \"self\" in kwargs else owner  # type: ignore[assignment]\n        if func_self is None:\n            raise RuntimeError(\"Missing self argument.\")\n\n        return func(func_self, *args, **kwargs)\n\n    return do\n</code></pre>"},{"location":"api-typing/","title":"<code>Dependency</code>","text":"<p>             Bases: <code>Protocol[Tcov]</code></p> <p>Generic FastAPI dependency function protocol.</p> Source code in <code>fasted/typing.py</code> <pre><code>class Dependency(Protocol[Tcov]):\n    \"\"\"Generic FastAPI dependency function protocol.\"\"\"\n\n    def __call__(\n        self, *args: Any, **kwargs: Any\n    ) -&gt; Tcov | Coroutine[Any, Any, Tcov] | Generator[Tcov, Any, Any] | AsyncGenerator[Tcov, Any]: ...\n</code></pre>"}]}